using AmsiProvider.Com;
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;

namespace AmsiProvider;

[GeneratedComClass]
internal partial class AntimalwareProvider : IAntimalwareProvider2
{
    private readonly ProviderConfig _config;

    public AntimalwareProvider(ProviderConfig config)
    {
        _config = config;
    }

    public unsafe int Scan(IAmsiStream stream)
    {
        try
        {
            string appName = GetStreamAttributeString(stream, AmsiAttribute.AMSI_ATTRIBUTE_APP_NAME);
            string contentName = GetStreamAttributeString(stream, AmsiAttribute.AMSI_ATTRIBUTE_CONTENT_NAME);
            long contentSize = 0;
            GetStreamAttribute(stream, AmsiAttribute.AMSI_ATTRIBUTE_CONTENT_SIZE, ref contentSize);
            nint contentAddr = nint.Zero;
            GetStreamAttribute(stream, AmsiAttribute.AMSI_ATTRIBUTE_CONTENT_ADDRESS, ref contentAddr);
            nint session = nint.Zero;
            GetStreamAttribute(stream, AmsiAttribute.AMSI_ATTRIBUTE_SESSION, ref session);
            // long chainSize = 0;
            // GetStreamAttribute(stream, AmsiAttribute.AMSI_ATTRIBUTE_REDIRECT_CHAIN_SIZE, ref chainSize);
            // nint chainAddr = nint.Zero;
            // GetStreamAttribute(stream, AmsiAttribute.AMSI_ATTRIBUTE_REDIRECT_CHAIN_ADDRESS, ref chainAddr);
            // long allSize = 0;
            // GetStreamAttribute(stream, AmsiAttribute.AMSI_ATTRIBUTE_ALL_SIZE, ref allSize);
            // nint allAddr = nint.Zero;
            // GetStreamAttribute(stream, AmsiAttribute.AMSI_ATTRIBUTE_ALL_ADDRESS, ref allAddr);

            if (contentAddr == nint.Zero)
            {
                _config.WriteEntry(
                    nameof(Scan),
                    appName,
                    contentName,
                    session.ToInt64(),
                    "IAmsiStream.Read() not yet implemented.");
            }
            else
            {
                _config.WriteEntry(
                    nameof(Scan),
                    appName,
                    contentName,
                    session.ToInt64(),
                    contentAddr,
                    (int)contentSize);
            }
        }
        catch (Exception e)
        {
            _config.WriteException("IAntimalwareProvider.Scan()", e);
        }

        return (int)AmsiResult.AMSI_RESULT_NOT_DETECTED;
    }

    public void CloseSession(long session)
    { }

    public string DisplayName()
        => Dll.ProviderName;

    public unsafe int Notify(
        nint buffer,
        int length,
        nint contentNamePtr,
        nint appNamePtr)
    {
        try
        {
            string appName = Marshal.PtrToStringUni(appNamePtr) ?? "";
            string contentName = Marshal.PtrToStringUni(contentNamePtr) ?? "";
            _config.WriteEntry(
                nameof(Notify),
                appName,
                contentName,
                0,
                buffer,
                length);
        }
        catch (Exception e)
        {
            _config.WriteException("IAntimalwareProvider2.Notify()", e);
        }

        return (int)AmsiResult.AMSI_RESULT_NOT_DETECTED;
    }

    private void GetStreamAttribute<T>(
        IAmsiStream stream,
        AmsiAttribute attribute,
        ref T value) where T : unmanaged
    {
        unsafe
        {
            fixed (void* valuePtr = &value)
            {
                int res = stream.GetAttribute(
                    (int)attribute,
                    Marshal.SizeOf<T>(),
                    (nint)valuePtr,
                    out int _);
                if (res == ComReturnValue.E_NOTIMPL)
                {
                    return;
                }
                else if (res != 0)
                {
                    throw new Win32Exception(res);
                }
            }
        }
    }

    private string GetStreamAttributeString(
        IAmsiStream stream,
        AmsiAttribute attribute)
    {
        int res = stream.GetAttribute((int)attribute, 0, IntPtr.Zero, out int size);
        if (res == ComReturnValue.E_INVALIDARG)
        {
            return "";
        }
        else if (res != ComReturnValue.E_NOT_SUFFICIENT_BUFFER)
        {
            throw new Win32Exception(res & 0xFFFF);
        }

        // string.Create guarantees a null terminator after the length so we
        // adjust the final length as it included the null char.
        return string.Create((size / 2) - 1, (stream, (int)attribute, size), static (chars, state) =>
        {
            (IAmsiStream stream, int attribute, int size) = state;

            int res;
            unsafe
            {
                fixed (char* charBuffer = chars)
                {
                    res = stream.GetAttribute(attribute, size, (nint)charBuffer, out int _);
                }
            }

            if (res != 0)
            {
                throw new Win32Exception(res);
            }

            chars.TrimEnd('\0');
        });
    }
}
